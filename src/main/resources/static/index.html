<script>
        let accessToken = null;
        let refreshToken = null;
        let currentUser = null;
        let currentSiteId = null;

        function getBaseUrl() {
            return document.getElementById('baseUrl').value;
        }

        function showResponse(elementId, data, isError = false) {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            element.querySelector('pre').textContent = JSON.stringify(data, null, 2);
            element.style.background = isError ? '#2d1e1e' : '#1e1e1e';
        }

        function showError(elementId, message) {
            showResponse(elementId, { error: message }, true);
        }

        async function makeApiCall(method, path, body, responseElementId, authRequired = true) {
            try {
                const headers = { 'Content-Type': 'application/json' };
                if (authRequired) {
                    if (!accessToken) throw new Error('로그인이 필요합니다.');
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                const options = {
                    method: method,
                    headers: headers
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }

                const response = await fetch(`${getBaseUrl()}${path}`, options);
                const data = await response.json();
                showResponse(responseElementId, data, !response.ok);
                return { ok: response.ok, data: data };
            } catch (error) {
                showError(responseElementId, error.message);
                return { ok: false, error: error.message };
            }
        }

        async function login() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;

            const result = await makeApiCall('POST', '/api/auth/login', { email, password }, 'loginResponse', false);

            if (result.ok && result.data.result === 'success' && result.data.data) {
                const loginData = result.data.data;
                accessToken = loginData.accessToken;
                refreshToken = loginData.refreshToken;
                currentUser = { email: loginData.userId || email }; // userId는 UUID일 수도, 이메일일 수도 있으므로 보수적으로 처리
                updateAuthUI();
                alert('로그인 성공!');
            } else if (result.ok) { // API 호출 성공했으나 result가 success가 아닌 경우 (예: 에러 응답)
                alert('로그인 실패: ' + (result.data.message || '알 수 없는 오류'));
            }
        }

        async function register() {
            const name = document.getElementById('regName').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;

            if (!name || !email || !password) {
                alert('모든 필드를 입력해주세요.');
                return;
            }

            const result = await makeApiCall('POST', '/api/auth/register', { name, email, password }, 'registerResponse', false);

            if (result.ok) {
                alert('회원가입 성공! 로그인해주세요.');
                document.getElementById('loginEmail').value = email;
                document.getElementById('loginPassword').value = password;
                switchTab('auth'); // 탭 스위칭 로직 수정 필요
            }
        }

        async function sendRegisterEmail() {
            const email = document.getElementById('regEmailSend').value;
            if (!email) {
                alert('이메일을 입력해주세요.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/register-email', { email }, 'registerEmailResponse', false);
            if (result.ok) {
                alert('인증번호가 이메일로 발송되었습니다.');
            }
        }

        async function verifyRegisterCode() {
            const email = document.getElementById('regEmailVerify').value;
            const verificationCode = document.getElementById('regCodeVerify').value;
            if (!email || !verificationCode) {
                alert('이메일과 인증번호를 입력해주세요.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/register-verificationCode', { email, verificationCode }, 'verifyRegisterCodeResponse', false);
            if (result.ok) {
                alert('인증번호 확인 성공!');
            }
        }

        async function logoutApi() {
            const result = await makeApiCall('POST', '/api/auth/logout', null, 'logoutResponse');
            if (result.ok) {
                alert('로그아웃 성공!');
                logoutClient(); // 클라이언트 측 토큰 삭제
            }
        }

        function logoutClient() {
            accessToken = null;
            refreshToken = null;
            currentUser = null;
            currentSiteId = null;
            updateAuthUI();
        }

        async function refreshTokenApi() {
            const currentRefreshToken = document.getElementById('refreshTokenInput').value || refreshToken;
            if (!currentRefreshToken) {
                alert('리프레시 토큰이 필요합니다.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/refresh', { refreshToken: currentRefreshToken }, 'refreshTokenResponse', false);
            if (result.ok && result.data.result === 'success' && result.data.data) {
                const newTokens = result.data.data;
                accessToken = newTokens.accessToken;
                refreshToken = newTokens.refreshToken;
                currentUser = { email: newTokens.userId }; // Refresh 응답에도 userId가 있습니다.
                updateAuthUI();
                alert('토큰이 갱신되었습니다!');
            } else if (result.ok) { // API 호출 성공했으나 result가 success가 아닌 경우 (예: 에러 응답)
                alert('토큰 갱신 실패: ' + (result.data.message || '알 수 없는 오류'));
            }
        }

        async function sendPasswordResetEmail() {
            const email = document.getElementById('passwordResetEmailSend').value;
            if (!email) {
                alert('이메일을 입력해주세요.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/password/reset-email', { email }, 'passwordResetEmailResponse', false);
            if (result.ok) {
                alert('비밀번호 재설정 이메일이 발송되었습니다.');
            }
        }

        async function verifyPasswordResetCode() {
            const email = document.getElementById('passwordResetEmailVerify').value;
            const code = document.getElementById('passwordResetCodeVerify').value;
            if (!email || !code) {
                alert('이메일과 인증번호를 입력해주세요.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/password/reset-verify', { email, code }, 'passwordResetVerifyResponse', false);
            if (result.ok) {
                alert('인증번호 확인 성공! 이제 새 비밀번호를 설정하세요.');
            }
        }

        async function completePasswordReset() {
            const email = document.getElementById('passwordResetEmailComplete').value;
            const newPassword = document.getElementById('newPasswordComplete').value;
            if (!email || !newPassword) {
                alert('이메일과 새 비밀번호를 입력해주세요.');
                return;
            }
            const result = await makeApiCall('POST', '/api/auth/password/reset-complete', { email, newPassword }, 'passwordResetCompleteResponse', false);
            if (result.ok) {
                alert('비밀번호가 성공적으로 재설정되었습니다!');
            }
        }
        
        function updateAuthUI() {
            const authStatus = document.getElementById('authStatus');
            const loginFormContainer = document.getElementById('loginForm');
            const loggedInInfo = document.getElementById('loggedInInfo');
            const userInfo = document.getElementById('userInfo');
            const tokenDisplay = document.getElementById('tokenDisplay');
            const refreshTokenInput = document.getElementById('refreshTokenInput');

            if (accessToken) {
                authStatus.textContent = '로그인됨';
                authStatus.className = 'status-badge logged-in';
                loginFormContainer.style.display = 'none';
                loggedInInfo.style.display = 'block';
                userInfo.textContent = `로그인: ${currentUser ? currentUser.email : '알 수 없음'}`;
                tokenDisplay.innerHTML = `<strong>Access Token:</strong> ${accessToken.substring(0, 50)}...<br><strong>Refresh Token:</strong> ${refreshToken ? refreshToken.substring(0, 50) + '...' : '없음'}`;
                if (refreshTokenInput) refreshTokenInput.value = refreshToken || ''; // 리프레시 토큰 입력 필드 업데이트 (페이지 로드 시 없을 수 있음)
            } else {
                authStatus.textContent = '로그아웃';
                authStatus.className = 'status-badge logged-out';
                loginFormContainer.style.display = 'block';
                loggedInInfo.style.display = 'none';
                userInfo.textContent = '';
                tokenDisplay.textContent = '';
                if (refreshTokenInput) refreshTokenInput.value = '';
            }
        }

        function getAuthHeaders() {
            if (!accessToken) {
                throw new Error('로그인이 필요합니다.');
            }
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            };
        }

        function updateGlobalSiteId(siteId) {
            currentSiteId = siteId;
            document.getElementById('globalSiteId').value = siteId;
        }

        function fillAllSiteIds() {
            if (!currentSiteId) {
                alert('사업장 ID가 없습니다. 먼저 사업장을 생성하거나 조회하세요.');
                return;
            }
            document.querySelectorAll('.site-id-field').forEach(input => {
                input.value = currentSiteId;
            });
            alert('모든 사업장 ID 필드에 적용되었습니다!');
        }

        async function getSites() {
            const result = await makeApiCall('GET', '/api/sites', null, 'getSitesResponse');
            if (result.ok && result.data.sites && result.data.sites.length > 0) {
                updateGlobalSiteId(result.data.sites[0].siteId); // SiteResponse.SiteInfo의 id 대신 siteId 사용
                fillAllSiteIds();
            }
        }

        async function createSite() {
            const requestBody = {
                name: document.getElementById('siteName').value,
                roadAddress: document.getElementById('siteRoadAddr').value,
                jibunAddress: document.getElementById('siteJibunAddr').value,
                latitude: parseFloat(document.getElementById('siteLatitude').value),
                longitude: parseFloat(document.getElementById('siteLongitude').value),
                type: document.getElementById('siteType').value
            };

            const result = await makeApiCall('POST', '/api/site', requestBody, 'createSiteResponse'); // Changed to /api/site
            if (result.ok && result.data.siteId) { // Changed to siteId
                alert('사업장 생성 성공!');
                updateGlobalSiteId(result.data.siteId);
                fillAllSiteIds();
            }
        }

        async function getSiteByName() {
            const siteName = document.getElementById('getSiteByNameInput').value;
            if (!siteName) {
                alert('사업장 이름을 입력하세요.');
                return;
            }
            const path = `/api/site?siteName=${encodeURIComponent(siteName)}`;
            const result = await makeApiCall('GET', path, null, 'getSiteByNameResponse');
        }

        async function updateSite() {
            const siteId = document.getElementById('updateSiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }

            const requestBody = {};
            const name = document.getElementById('updateSiteName').value;
            const latitudeStr = document.getElementById('updateSiteLatitude').value;
            const longitudeStr = document.getElementById('updateSiteLongitude').value;
            const type = document.getElementById('updateSiteType').value;

            if (name) requestBody.name = name;
            if (latitudeStr) requestBody.latitude = parseFloat(latitudeStr);
            if (longitudeStr) requestBody.longitude = parseFloat(longitudeStr);
            if (type) requestBody.type = type;

            if (Object.keys(requestBody).length === 0) {
                alert('수정할 내용을 하나 이상 입력하세요.');
                return;
            }
            
            const path = `/api/site?siteId=${siteId}`;
            const result = await makeApiCall('PATCH', path, requestBody, 'updateSiteResponse');
            if (result.ok) {
                alert('사업장 수정 성공!');
            }
        }

        async function deleteSite() {
            const siteId = document.getElementById('deleteSiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }
            const path = `/api/site?siteId=${siteId}`;
            const result = await makeApiCall('DELETE', path, null, 'deleteSiteResponse');
            if (result.ok) {
                alert('사업장 삭제 성공!');
                if (currentSiteId === siteId) {
                    currentSiteId = null;
                    document.getElementById('globalSiteId').value = '';
                }
                fillAllSiteIds();
            }
        }

        async function startAnalysis() {
            const siteId = document.getElementById('analysisSiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }

            const requestBody = {
                sites: [{ siteId: siteId }]
            };

            const result = await makeApiCall('POST', '/api/analysis/start', requestBody, 'startAnalysisResponse');
            if (result.ok && result.data.jobId) { // FastAPI Job ID는 FastAPI 응답에 있음 (Spring Boot는 Void 반환)
                 // FastAPI 응답 형식에 따라 수정 필요 (현재 Spring Boot는 Void를 반환하므로 jobId를 받지 못함)
                 // 여기서는 Mock으로 처리하거나, 실제 Spring Boot 응답 DTO에 jobId가 추가되어야 함
                document.getElementById('statusJobId').value = "mock-job-id-" + siteId; // 임시 Mock ID
                alert('분석 시작! Job ID (Mock): ' + document.getElementById('statusJobId').value);
            } else if (result.ok) { // Spring Boot에서 성공 응답만 오는 경우
                alert('분석 시작 요청 성공. Job ID는 Spring Boot 응답에 포함되지 않습니다.');
            }
        }

        async function getAnalysisStatus() {
            const jobid = document.getElementById('statusJobId').value;
            const userId = currentUser ? currentUser.email : ''; // FastAPI 클라이언트에서 userId를 요구함.
            const path = jobid
                ? `/api/analysis/status?jobid=${jobid}`
                : `/api/analysis/status`;
            const result = await makeApiCall('GET', path, null, 'analysisStatusResponse');
        }

        async function getAnalysisSummary() {
            const siteId = document.getElementById('summarySiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }
            const path = `/api/analysis/summary?siteId=${siteId}`;
            const result = await makeApiCall('GET', path, null, 'summaryResponse');
        }

        async function getPhysicalRisk() {
            const siteId = document.getElementById('physicalRiskSiteId').value;
            const term = document.getElementById('physicalRiskTerm').value;
            const hazardType = document.getElementById('physicalRiskHazardType').value;

            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }

            const path = `/api/analysis/physical-risk?siteId=${siteId}&term=${term}&hazardType=${encodeURIComponent(hazardType)}`;
            const result = await makeApiCall('GET', path, null, 'physicalRiskResponse');
        }

        async function getAal() {
            const siteId = document.getElementById('aalSiteId').value;
            const term = document.getElementById('aalTerm').value;
            const hazardType = document.getElementById('aalHazardType').value;

            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }

            const path = `${getBaseUrl()}/api/analysis/aal?siteId=${siteId}&term=${term}&hazardType=${encodeURIComponent(hazardType)}`;
            const result = await makeApiCall('GET', path, null, 'aalResponse');
        }

        async function getVulnerability() {
            const siteId = document.getElementById('vulnerabilitySiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }
            const path = `/api/analysis/vulnerability?siteId=${siteId}`;
            const result = await makeApiCall('GET', path, null, 'vulnerabilityResponse');
        }

        async function getDashboard() {
            const result = await makeApiCall('GET', '/api/dashboard', null, 'dashboardResponse');
        }

        async function getLocationRecommendation() {
            const siteId = document.getElementById('recSiteId').value;
            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }
            const path = `/api/simulation/location/recommendation?siteId=${siteId}`;
            const result = await makeApiCall('GET', path, null, 'recommendationResponse');
        }

        async function compareLocation() {
            const siteId = document.getElementById('compareCurrentSiteId').value; // siteId로 변경
            const latitude = parseFloat(document.getElementById('compareLatitude').value);
            const longitude = parseFloat(document.getElementById('compareLongitude').value);
            const roadAddress = document.getElementById('compareRoadAddr').value;
            const jibunAddress = document.getElementById('compareJibunAddr').value;

            if (!siteId || isNaN(latitude) || isNaN(longitude)) {
                alert('사업장 ID, 위도, 경도는 필수입니다.');
                return;
            }

            const requestBody = {
                siteId: siteId, // currentSiteId를 siteId로 변경
                candidate: {
                    latitude: latitude,
                    longitude: longitude,
                    roadAddress: roadAddress,
                    jibunAddress: jibunAddress
                }
            };
            const result = await makeApiCall('POST', '/api/simulation/location/compare', requestBody, 'compareResponse');
        }

        async function runClimateSimulation() {
            const requestBody = {
                scenario: document.getElementById('climateScenario').value,
                hazardType: document.getElementById('climateHazardType').value
            };
            const result = await makeApiCall('POST', '/api/simulation/climate', requestBody, 'climateResponse');
        }

        async function getReport() {
            const result = await makeApiCall('GET', '/api/report', null, 'reportResponse');
        }

        async function registerReportData() {
            const siteId = document.getElementById('reportDataSiteId').value;
            const dataContent = document.getElementById('reportDataContent').value;

            if (!siteId) {
                alert('사업장 ID를 입력하세요.');
                return;
            }

            let parsedData;
            try {
                parsedData = dataContent ? JSON.parse(dataContent) : {};
            } catch (e) {
                alert('잘못된 JSON 형식입니다.');
                return;
            }

            const requestBody = {
                siteId: siteId,
                data: parsedData // JSON 객체 자체를 'data' 필드에 넣음
            };

            const result = await makeApiCall('POST', '/api/report/data', requestBody, 'reportDataResponse');
            if (result.ok) {
                alert('리포트 데이터 등록 성공!');
            }
        }

        async function getPastDisasters() {
            const year = document.getElementById('pastYear').value;
            const disasterType = document.getElementById('pastDisasterType').value;
            const severity = document.getElementById('pastSeverity').value;

            const path = `/api/past?year=${year}&disaster_type=${encodeURIComponent(disasterType)}&severity=${encodeURIComponent(severity)}`;
            const result = await makeApiCall('GET', path, null, 'pastResponse');
        }

        function switchTab(tabName) {
            // 모든 탭 버튼과 콘텐츠 비활성화
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // 선택된 탭 활성화
            const clickedButton = event.target.closest('.tab-button');
            if (clickedButton) {
                clickedButton.classList.add('active');
            } else {
                // event.target이 탭 버튼이 아닐 경우 (예: showRegisterForm에서 호출)
                document.querySelector(`.tab-buttons button[onclick="switchTab('${tabName}')"]`).classList.add('active');
            }
            document.getElementById(tabName + 'Tab').classList.add('active');
        }
        
        function showRegisterForm() {
            switchTab('auth');
            // 회원가입 폼으로 스크롤 이동 또는 특정 회원가입 섹션 활성화 로직 추가 가능
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            // 현재 페이지의 origin을 baseUrl로 설정
            const currentOrigin = window.location.origin;
            document.getElementById('baseUrl').value = currentOrigin;
            updateAuthUI();
            
            // 초기 로딩 시 'auth' 탭을 활성화
            document.querySelector('.tab-buttons .tab-button').classList.add('active');
            document.getElementById('authTab').classList.add('active');
        });
    </script>